using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using Xcaciv.LooseNotes.Web.Data;
using Xcaciv.LooseNotes.Web.Models;
using Xcaciv.LooseNotes.Web.Services;
using Xunit;

namespace Xcaciv.LooseNotes.Web.Tests.Vulns
{
    public class IDORVulnerabilityTests : IDisposable
    {
        private readonly ApplicationDbContext _context;
        private readonly NoteService _noteService;
        private readonly RatingService _ratingService;
        private readonly UserService _userService;

        public IDORVulnerabilityTests()
        {
            // Create a unique in-memory database for each test
            var options = new DbContextOptionsBuilder<ApplicationDbContext>()
                .UseInMemoryDatabase(databaseName: $"IDORTest_{Guid.NewGuid()}")
                .Options;

            _context = new ApplicationDbContext(options);
            _noteService = new NoteService(_context);
            _ratingService = new RatingService(_context);
            _userService = new UserService(_context);

            // Seed the database with test data
            SeedTestData();
        }

        private void SeedTestData()
        {
            // Add test users
            var users = new List<User>
            {
                new User { Id = 1, Username = "user1", Email = "user1@example.com", Password = "password1", Role = "user" },
                new User { Id = 2, Username = "user2", Email = "user2@example.com", Password = "password2", Role = "user" },
                new User { Id = 3, Username = "admin", Email = "admin@example.com", Password = "adminpass", Role = "admin" }
            };

            // Add test notes
            var notes = new List<Note>
            {
                new Note 
                { 
                    Id = 1, 
                    Title = "User1's Private Note", 
                    Content = "This should only be accessible to user1", 
                    UserId = 1, 
                    IsPublic = false,
                    CreatedAt = DateTime.Now.AddDays(-5),
                    ShareToken = Guid.NewGuid().ToString()
                },
                new Note 
                { 
                    Id = 2, 
                    Title = "User2's Private Note", 
                    Content = "This should only be accessible to user2", 
                    UserId = 2, 
                    IsPublic = false,
                    CreatedAt = DateTime.Now.AddDays(-3),
                    ShareToken = Guid.NewGuid().ToString()
                },
                new Note 
                { 
                    Id = 3, 
                    Title = "User1's Public Note", 
                    Content = "This is public and can be accessed by anyone", 
                    UserId = 1, 
                    IsPublic = true,
                    CreatedAt = DateTime.Now.AddDays(-1),
                    ShareToken = Guid.NewGuid().ToString()
                }
            };

            // Add test ratings
            var ratings = new List<Rating>
            {
                new Rating 
                { 
                    Id = 1, 
                    NoteId = 3, // Rating on the public note
                    UserId = 2, 
                    Stars = 4, 
                    Comment = "Good public note", 
                    CreatedAt = DateTime.Now.AddDays(-1),
                    IsVerified = true,
                    AllowHtml = false,
                    IpAddress = "192.168.1.1"
                },
                new Rating 
                { 
                    Id = 2, 
                    NoteId = 1, // Rating on user1's private note
                    UserId = 1, 
                    Stars = 5, 
                    Comment = "My own private note rating", 
                    CreatedAt = DateTime.Now,
                    IsVerified = true,
                    AllowHtml = false,
                    IpAddress = "192.168.1.2"
                }
            };

            _context.Users.AddRange(users);
            _context.Notes.AddRange(notes);
            _context.Ratings.AddRange(ratings);
            _context.SaveChanges();
        }

        public void Dispose()
        {
            _context.Database.EnsureDeleted();
            _context.Dispose();
        }

        [Fact]
        public void NoteService_DirectNote_AccessWithoutCheckingOwnership()
        {
            // Arrange - User2 attempting to access User1's private note
            int privateNoteId = 1;     // User1's private note
            int unauthorizedUserId = 2; // User2 is not the owner

            // Act - No authorization check is performed
            var note = _noteService.GetById(privateNoteId);

            // Assert - Vulnerability: User's private note is accessible without any owner verification
            Assert.NotNull(note);
            Assert.Equal(privateNoteId, note.Id);
            Assert.Equal(1, note.UserId); // Note belongs to User1
            Assert.NotEqual(unauthorizedUserId, note.UserId); // Not the requestor's note
        }

        [Fact]
        public void NoteService_Update_AllowsUnauthorizedModification()
        {
            // Arrange - User2 attempting to modify User1's note
            var privateNote = _noteService.GetById(1);
            string originalTitle = privateNote.Title;
            string unauthorized = "Modified by unauthorized user";

            // Act - Modify the note without authentication/authorization
            privateNote.Title = unauthorized;
            _noteService.Update(privateNote);

            // Assert - Vulnerability: Note can be modified without owner verification
            var modifiedNote = _noteService.GetById(1);
            Assert.Equal(unauthorized, modifiedNote.Title);
            Assert.NotEqual(originalTitle, modifiedNote.Title);
        }

        [Fact]
        public void NoteService_Delete_AllowsUnauthorizedDeletion()
        {
            // Arrange
            int privateNoteId = 1; // User1's private note
            
            // Act - Delete without authorization check
            _noteService.Delete(privateNoteId);

            // Assert - Vulnerability: Note can be deleted without ownership verification
            var deletedNote = _noteService.GetById(privateNoteId);
            Assert.Null(deletedNote);
        }

        [Fact]
        public void RatingService_GetById_AccessWithoutCheckingOwnership()
        {
            // Arrange
            int privateRatingId = 2; // Rating for User1's private note

            // Act - Access rating without authorization
            var rating = _ratingService.GetById(privateRatingId);

            // Assert - Vulnerability: Rating for private note is accessible
            Assert.NotNull(rating);
            Assert.Equal(privateRatingId, rating.Id);
        }

        [Fact]
        public void RatingService_GetRatingsByNoteId_NoAuthorizationCheck()
        {
            // Arrange
            int privateNoteId = 1; // User1's private note

            // Act - Get ratings for a private note without authorization
            var ratings = _ratingService.GetRatingsByNoteId(privateNoteId);

            // Assert - Vulnerability: Ratings for private note are accessible
            Assert.Single(ratings);
            Assert.Equal(privateNoteId, ratings[0].NoteId);
        }

        [Fact]
        public void RatingService_UpdateRating_AllowsUnauthorizedModification()
        {
            // Arrange
            var rating = _ratingService.GetById(1);
            int originalStars = rating.Stars;
            string originalComment = rating.Comment;

            // Act - Modify rating without authorization check
            rating.Stars = 1;
            rating.Comment = "Modified by unauthorized user";
            _ratingService.UpdateRating(rating);

            // Assert - Vulnerability: Rating can be modified without authorization
            var modifiedRating = _ratingService.GetById(1);
            Assert.Equal(1, modifiedRating.Stars);
            Assert.NotEqual(originalStars, modifiedRating.Stars);
            Assert.NotEqual(originalComment, modifiedRating.Comment);
        }

        [Fact]
        public void UserService_GetById_AllowsAccessToAnyUser()
        {
            // Arrange - Any user ID
            int adminUserId = 3;

            // Act - Access user without authentication
            var user = _userService.GetById(adminUserId);

            // Assert - Vulnerability: Any user's details are accessible
            Assert.NotNull(user);
            Assert.Equal("admin", user.Username);
            Assert.Equal("adminpass", user.Password); // Also verifies plaintext password storage
        }

        [Fact]
        public void UserService_Update_AllowsUnauthorizedModification()
        {
            // Arrange
            var user = _userService.GetById(3); // Admin user
            string originalRole = user.Role;

            // Act - Unauthorized role change
            user.Role = "user"; // Downgrade from admin
            _userService.Update(user);

            // Assert - Vulnerability: User's role can be changed without authorization
            var modifiedUser = _userService.GetById(3);
            Assert.Equal("user", modifiedUser.Role);
            Assert.NotEqual(originalRole, modifiedUser.Role);
        }

        [Fact]
        public void NoteService_ShareToken_PredictableOrWeak()
        {
            // This test checks if share tokens are predictable or reused
            // Note: This is a simplified check - in production, a more thorough analysis would be needed
            
            // Arrange
            var note1 = new Note
            {
                // Using higher IDs to avoid conflicts with existing test data
                Id = 101,
                Title = "Test Note for Token 1",
                Content = "Content 1",
                UserId = 1,
                IsPublic = false
            };
            
            var note2 = new Note
            {
                Id = 102,
                Title = "Test Note for Token 2",
                Content = "Content 2",
                UserId = 1,
                IsPublic = false
            };

            // Act
            note1 = _noteService.Create(note1);
            note2 = _noteService.Create(note2);

            // Assert - Vulnerability: Tokens should be unguessable and unique
            Assert.NotNull(note1.ShareToken);
            Assert.NotNull(note2.ShareToken);
            Assert.NotEqual(note1.ShareToken, note2.ShareToken);
        }

        [Fact]
        public void UserService_PasswordReset_IDORVulnerable()
        {
            // Arrange
            string email = "user1@example.com";
            string newPassword = "hacked123";
            
            // Act - Generate token, which should be a private operation
            string token = _userService.GeneratePasswordResetToken(email);
            
            // Use token to reset password without proper authorization
            bool result = _userService.ResetPassword(email, token, newPassword);
            
            // Assert - Vulnerability: Password can be reset with just a token
            Assert.True(result);
            
            // Verify password was changed
            var user = _userService.Authenticate("user1", newPassword);
            Assert.NotNull(user);
        }
    }
}